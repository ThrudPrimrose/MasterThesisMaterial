Kernel 12, N: 32
FileName: benchmark_cuda_tensor_3_variant_012_N_32.cu
Dimensions: 32, 32, 32
Indices: ijk-ixk-xjk
Gemmforge Tensor Contraction took: 35.3652 ms
Gemmforge Kernel GFLOPs/s: 543.781
Operational intensity: 5.33333
13.4142 % of roof w. respect to operational intensity achieved with Gemmforge
cuTensor Kernel 1
21.9828 % of roof w. respect to operational intensity achieved with cuTensor
Gemmforge and cuTensor contraction results match! :)
Kernel 6, N: 32
FileName: benchmark_cuda_tensor_3_variant_06_N_32.cu
Dimensions: 32, 32, 32
Indices: ijk-xki-xjk
Gemmforge Tensor Contraction took: 21.3579 ms
Gemmforge Kernel GFLOPs/s: 900.413
Operational intensity: 5.33333
22.2118 % of roof w. respect to operational intensity achieved with Gemmforge
cuTensor Kernel 1
16.7504 % of roof w. respect to operational intensity achieved with cuTensor
Gemmforge and cuTensor contraction results match! :)
Kernel 4, N: 31
FileName: benchmark_cuda_tensor_3_variant_04_N_31.cu
Dimensions: 31, 31, 31
Indices: ijk-ikx-jxk
Gemmforge Tensor Contraction took: 23.5778 ms
Gemmforge Kernel GFLOPs/s: 790.12
Operational intensity: 5.16667
20.1198 % of roof w. respect to operational intensity achieved with Gemmforge
cuTensor Kernel 1
22.1872 % of roof w. respect to operational intensity achieved with cuTensor
Gemmforge and cuTensor contraction results match! :)
Kernel 6, N: 16
FileName: benchmark_cuda_tensor_3_variant_06_N_16.cu
Dimensions: 16, 16, 16
Indices: ijk-xki-xjk
Gemmforge Tensor Contraction took: 22.1507 ms
Gemmforge Kernel GFLOPs/s: 434.015
Operational intensity: 2.66667
21.4129 % of roof w. respect to operational intensity achieved with Gemmforge
cuTensor Kernel 1
5.25543 % of roof w. respect to operational intensity achieved with cuTensor
Gemmforge and cuTensor contraction results match! :)
Kernel 5, N: 31
FileName: benchmark_cuda_tensor_3_variant_05_N_31.cu
Dimensions: 31, 31, 31
Indices: ijk-xik-xkj
Gemmforge Tensor Contraction took: 32.8372 ms
Gemmforge Kernel GFLOPs/s: 567.322
Operational intensity: 5.16667
14.4464 % of roof w. respect to operational intensity achieved with Gemmforge
cuTensor Kernel 1
11.0267 % of roof w. respect to operational intensity achieved with cuTensor
Gemmforge and cuTensor contraction results match! :)
Kernel 5, N: 32
FileName: benchmark_cuda_tensor_3_variant_05_N_32.cu
Dimensions: 32, 32, 32
Indices: ijk-xik-xkj
Gemmforge Tensor Contraction took: 26.4431 ms
Gemmforge Kernel GFLOPs/s: 727.256
Operational intensity: 5.33333
17.9403 % of roof w. respect to operational intensity achieved with Gemmforge
cuTensor Kernel 1
17.6805 % of roof w. respect to operational intensity achieved with cuTensor
Gemmforge and cuTensor contraction results match! :)
Kernel 12, N: 16
FileName: benchmark_cuda_tensor_3_variant_012_N_16.cu
Dimensions: 16, 16, 16
Indices: ijk-ixk-xjk
Gemmforge Tensor Contraction took: 35.433 ms
Gemmforge Kernel GFLOPs/s: 271.321
Operational intensity: 2.66667
13.3862 % of roof w. respect to operational intensity achieved with Gemmforge
cuTensor Kernel 1
7.04451 % of roof w. respect to operational intensity achieved with cuTensor
Gemmforge and cuTensor contraction results match! :)
============================================
["'x'", "'k'", "'i'"] ["'k'", "'x'", "'j'"] ["'i'", "'j'", "'k'"]
xki kxj ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b4fd90>)
dense(shape=(16, 16), size=256, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 16*_k;
[_POINTER] float const* _B = B + 1*_k;
[_POINTER] float * _C = C + 256*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 16*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'k'", "'x'", "'i'"] ["'j'", "'k'", "'x'"] ["'i'", "'j'", "'k'"]
kxi jkx ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b5cf10>)
dense(shape=(16, 16), size=256, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = B + 16*_k;
[_POINTER] float const* _B = A + 1*_k;
[_POINTER] float * _C = _tmp0 + 256*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 16*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 1*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 256*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'k'", "'i'", "'x'"] ["'x'", "'k'", "'j'"] ["'i'", "'j'", "'k'"]
kix xkj ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(16, 256), align=<yateto.arch.Architecture object at 0x7f5e94b68910>)
dense(shape=(16, 16), size=256, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 1*_k;
[_POINTER] float const* _B = B + 16*_k;
[_POINTER] float * _C = C + 256*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 16*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'i'", "'k'", "'x'"] ["'j'", "'x'", "'k'"] ["'i'", "'j'", "'k'"]
ikx jxk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b5d7d0>)
dense(shape=(16, 16), size=256, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 16*_k;
[_POINTER] float const* _B = B + 256*_k;
[_POINTER] float * _C = C + 256*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 16*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b5d7d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b5d7d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b5d7d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=True,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
[('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 16*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b5d7d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b5d7d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b5d7d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=True,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
0 ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
1 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 16*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
2 ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b5d7d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b5d7d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b5d7d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=True,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
Add:  DenseMatrix{name = A
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 256
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = B
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = C
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SINK
}
3 ('forLoopEnd', {})
{DenseMatrix{name = C, num. rows = 16, num. columns = 16, leading dimension = 16, direction = DataFlowDirection.SINK, bbox = [0, 0, 16, 16]}, DenseMatrix{name = A, num. rows = 16, num. columns = 16, leading dimension = 256, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 16, 16]}, DenseMatrix{name = B, num. rows = 16, num. columns = 16, leading dimension = 16, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 16, 16]}}
[('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 16*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b5d7d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b5d7d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b5d7d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=True,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 16*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b5d7d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b5d7d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b5d7d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=True,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
Calling external code generators...
{}
//Original Loop: const float* _A = A + 16*_k
//Original Loop: const float* _B = B + 256*_k
//Original Loop: float* _C = C + 256*_k
rows: 16, cols: 16, lid: 256, trans: False
Generating initialization code...
sloopOverGEMM_NT_NT_NT__d16_16_d16_16_d16_16__alpha_1_0_beta_0_0_p_p_p__7dfa36b
const float * const * A, int A_extraOffset, const float * const * B, int B_extraOffset, float ** C, int C_extraOffset, unsigned numElements, unsigned* flags, void* streamPtr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
============================================
["'x'", "'i'", "'k'"] ["'x'", "'k'", "'j'"] ["'i'", "'j'", "'k'"]
xik xkj ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b4e6d0>)
dense(shape=(16, 16), size=256, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 256*_k;
[_POINTER] float const* _B = B + 16*_k;
[_POINTER] float * _C = C + 256*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 16*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b4e6d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b4e6d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b4e6d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
[('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 16*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b4e6d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b4e6d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b4e6d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
0 ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
1 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 16*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
2 ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b4e6d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b4e6d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b4e6d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
Add:  DenseMatrix{name = A
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = B
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 256
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = C
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SINK
}
3 ('forLoopEnd', {})
{DenseMatrix{name = C, num. rows = 16, num. columns = 16, leading dimension = 16, direction = DataFlowDirection.SINK, bbox = [0, 0, 16, 16]}, DenseMatrix{name = B, num. rows = 16, num. columns = 16, leading dimension = 256, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 16, 16]}, DenseMatrix{name = A, num. rows = 16, num. columns = 16, leading dimension = 16, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 16, 16]}}
[('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 16*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b4e6d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b4e6d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b4e6d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 16*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b4e6d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b4e6d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b4e6d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
Calling external code generators...
{}
//Original Loop: const float* _A = A + 256*_k
//Original Loop: const float* _B = B + 16*_k
//Original Loop: float* _C = C + 256*_k
rows: 16, cols: 16, lid: 256, trans: False
Generating initialization code...
sloopOverGEMM_NT_NT_NT__d16_16_d16_16_d16_16__alpha_1_0_beta_0_0_p_p_p__b7be2b6
const float * const * A, int A_extraOffset, const float * const * B, int B_extraOffset, float ** C, int C_extraOffset, unsigned numElements, unsigned* flags, void* streamPtr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
============================================
["'x'", "'k'", "'i'"] ["'x'", "'j'", "'k'"] ["'i'", "'j'", "'k'"]
xki xjk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b6c850>)
dense(shape=(16, 16), size=256, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 16*_k;
[_POINTER] float const* _B = B + 256*_k;
[_POINTER] float * _C = C + 256*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 16*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c850>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b6c850>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c850>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
[('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 16*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c850>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b6c850>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c850>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
0 ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
1 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 16*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
2 ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c850>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b6c850>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c850>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
Add:  DenseMatrix{name = A
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 256
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = B
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = C
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SINK
}
3 ('forLoopEnd', {})
{DenseMatrix{name = C, num. rows = 16, num. columns = 16, leading dimension = 16, direction = DataFlowDirection.SINK, bbox = [0, 0, 16, 16]}, DenseMatrix{name = A, num. rows = 16, num. columns = 16, leading dimension = 256, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 16, 16]}, DenseMatrix{name = B, num. rows = 16, num. columns = 16, leading dimension = 16, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 16, 16]}}
[('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 16*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c850>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b6c850>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c850>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 16*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c850>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b6c850>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c850>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
Calling external code generators...
{}
//Original Loop: const float* _A = A + 16*_k
//Original Loop: const float* _B = B + 256*_k
//Original Loop: float* _C = C + 256*_k
Generating initialization code...
sloopOverGEMM_NT_NT_NT__d16_16_d16_16_d16_16__alpha_1_0_beta_0_0_p_p_p__7dfa36b
const float * const * A, int A_extraOffset, const float * const * B, int B_extraOffset, float ** C, int C_extraOffset, unsigned numElements, unsigned* flags, void* streamPtr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
============================================
["'k'", "'x'", "'i'"] ["'x'", "'j'", "'k'"] ["'i'", "'j'", "'k'"]
kxi xjk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(16, 256), align=<yateto.arch.Architecture object at 0x7f5e94b5d210>)
dense(shape=(16, 16), size=256, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 1*_k;
[_POINTER] float const* _B = B + 256*_k;
[_POINTER] float * _C = C + 256*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'k'", "'i'", "'x'"] ["'x'", "'j'", "'k'"] ["'i'", "'j'", "'k'"]
kix xjk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(16, 256), align=<yateto.arch.Architecture object at 0x7f5e94b6e010>)
dense(shape=(16, 16), size=256, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 1*_k;
[_POINTER] float const* _B = B + 256*_k;
[_POINTER] float * _C = C + 256*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'k'", "'i'", "'x'"] ["'j'", "'x'", "'k'"] ["'i'", "'j'", "'k'"]
kix jxk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(16, 256), align=<yateto.arch.Architecture object at 0x7f5e94b5f0d0>)
dense(shape=(16, 16), size=256, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 1*_k;
[_POINTER] float const* _B = B + 256*_k;
[_POINTER] float * _C = C + 256*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'i'", "'x'", "'k'"] ["'x'", "'k'", "'j'"] ["'i'", "'j'", "'k'"]
ixk xkj ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b69b50>)
dense(shape=(16, 16), size=256, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 256*_k;
[_POINTER] float const* _B = B + 16*_k;
[_POINTER] float * _C = C + 256*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 16*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b69b50>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b69b50>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b69b50>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
[('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 16*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b69b50>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b69b50>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b69b50>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
0 ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
1 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 16*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
2 ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b69b50>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b69b50>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b69b50>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
Add:  DenseMatrix{name = A
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = B
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 256
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = C
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SINK
}
3 ('forLoopEnd', {})
{DenseMatrix{name = A, num. rows = 16, num. columns = 16, leading dimension = 16, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 16, 16]}, DenseMatrix{name = C, num. rows = 16, num. columns = 16, leading dimension = 16, direction = DataFlowDirection.SINK, bbox = [0, 0, 16, 16]}, DenseMatrix{name = B, num. rows = 16, num. columns = 16, leading dimension = 256, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 16, 16]}}
[('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 16*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b69b50>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b69b50>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b69b50>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 16*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b69b50>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b69b50>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e94b69b50>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
Calling external code generators...
{}
//Original Loop: const float* _A = A + 256*_k
//Original Loop: const float* _B = B + 16*_k
//Original Loop: float* _C = C + 256*_k
rows: 16, cols: 16, lid: 256, trans: False
Generating initialization code...
sloopOverGEMM_NT_NT_NT__d16_16_d16_16_d16_16__alpha_1_0_beta_0_0_p_p_p__41a5782
const float * const * A, int A_extraOffset, const float * const * B, int B_extraOffset, float ** C, int C_extraOffset, unsigned numElements, unsigned* flags, void* streamPtr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
============================================
["'x'", "'i'", "'k'"] ["'j'", "'x'", "'k'"] ["'i'", "'j'", "'k'"]
xik jxk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6f9d0>)
dense(shape=(16, 16), size=256, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = B + 256*_k;
[_POINTER] float const* _B = A + 256*_k;
[_POINTER] float * _C = _tmp0 + 256*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 256*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6f9d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6f9d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6f9d0>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
Calling external code generators...
Generating initialization code...
Skip ScopScaleAdd
*********************************
============================================
["'i'", "'x'", "'k'"] ["'x'", "'j'", "'k'"] ["'i'", "'j'", "'k'"]
ixk xjk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>)
dense(shape=(16, 16), size=256, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 256*_k;
[_POINTER] float const* _B = B + 256*_k;
[_POINTER] float * _C = C + 256*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
[('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 256*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {}), ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
0 ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
1 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 256*_k'}})
2 ('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']})
Rename: DenseMatrix{name = tmp0
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = strided
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = None
}
Add:  DenseMatrix{name = B
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = A
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = tmp0
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = strided
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SINK
}
3 ('forLoopEnd', {})
4 ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
5 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
6 ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
Add:  DenseMatrix{name = A
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SOURCESINK
}
Add:  DenseMatrix{name = B
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SOURCESINK
}
Add:  DenseMatrix{name = C
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SINK
}
7 ('forLoopEnd', {})
{DenseMatrix{name = B, num. rows = 16, num. columns = 16, leading dimension = 16, direction = DataFlowDirection.SOURCESINK, bbox = [0, 0, 16, 16]}, DenseMatrix{name = tmp0, num. rows = 16, num. columns = 16, leading dimension = 16, direction = DataFlowDirection.SINK, bbox = [0, 0, 16, 16]}, DenseMatrix{name = C, num. rows = 16, num. columns = 16, leading dimension = 16, direction = DataFlowDirection.SINK, bbox = [0, 0, 16, 16]}, DenseMatrix{name = A, num. rows = 16, num. columns = 16, leading dimension = 16, direction = DataFlowDirection.SOURCESINK, bbox = [0, 0, 16, 16]}}
[('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 256*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {}), ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 256*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 256*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b6c490>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
Calling external code generators...
{'_tmp0': 256}
ADD: DenseMatrix{name = _tmp0_buffer
	num. rows = 256
	num. columns = 1
	bounding box = [0, 0, 256, 1]
	addressing = none
	num. actual rows = 256
	num. actual cols = 1
	leading dimension = 256
	direction = DataFlowDirection.SOURCESINK
}, AS SYMBOL: name: _tmp0_buffer, type: SymbolType.SharedMem
DenseMatrix{name = B
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SOURCESINK
} tmp0
DenseMatrix{name = tmp0
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = strided
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SINK
} tmp0
ADD: DenseMatrix{name = tmp0
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = strided
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SINK
}, AS SYMBOL: name: tmp0, type: SymbolType.SharedMem
DenseMatrix{name = C
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SINK
} tmp0
DenseMatrix{name = A
	num. rows = 16
	num. columns = 16
	bounding box = [0, 0, 16, 16]
	addressing = pointer_based
	num. actual rows = 16
	num. actual cols = 16
	leading dimension = 16
	direction = DataFlowDirection.SOURCESINK
} tmp0
//Original Loop: const float* _A = B + 256*_k
//Original Loop: const float* _B = A + 256*_k
//Original Loop: float* _C = _tmp0 + 256*_k
//Original Loop: const float* _A = A + 256*_k
//Original Loop: const float* _B = B + 256*_k
//Original Loop: float* _C = C + 256*_k
Generating initialization code...
sloopOverGEMM_NT_NT__d16_16_d16_16__alpha_1_0alpha_1_0_beta_0_0beta_0_0_s_p__86c9c40
float ** A, int A_extraOffset, float ** B, int B_extraOffset, float ** C, int C_extraOffset, unsigned numElements, unsigned* flags, void* streamPtr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
============================================
["'i'", "'x'", "'k'"] ["'k'", "'x'", "'j'"] ["'i'", "'j'", "'k'"]
ixk kxj ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e94b5ced0>)
dense(shape=(16, 16), size=256, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 256*_k;
[_POINTER] float const* _B = B + 1*_k;
[_POINTER] float * _C = C + 256*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 256*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'x'", "'k'", "'i'"] ["'j'", "'x'", "'k'"] ["'i'", "'j'", "'k'"]
xki jxk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e9e87ab10>)
dense(shape=(16, 16), size=256, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '16', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = B + 256*_k;
[_POINTER] float const* _B = A + 16*_k;
[_POINTER] float * _C = _tmp0 + 256*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 256*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 16*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 256*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e9e87ab10>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 16), align=<yateto.arch.Architecture object at 0x7f5e9e87ab10>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(16, 16), bbox=BoundingBox(Range(0, 16), Range(0, 16)), stride=(1, 256), align=<yateto.arch.Architecture object at 0x7f5e9e87ab10>),	  eqspp=dense(shape=(16, 16), size=256, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 16), Range(0, 16), Range(0, 16))), 'matrix_a': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_b': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 256, direction = None, bbox = [0, 0, 16, 16]}, 'matrix_c': DenseMatrix{name = None, num. rows = 16, num. columns = 16, leading dimension = 16, direction = None, bbox = [0, 0, 16, 16]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
Calling external code generators...
Generating initialization code...
Skip ScopScaleAdd
*********************************
============================================
["'x'", "'k'", "'i'"] ["'k'", "'x'", "'j'"] ["'i'", "'j'", "'k'"]
xki kxj ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b6b2d0>)
dense(shape=(31, 31), size=961, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 31*_k;
[_POINTER] float const* _B = B + 1*_k;
[_POINTER] float * _C = C + 961*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 31*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'k'", "'x'", "'i'"] ["'j'", "'k'", "'x'"] ["'i'", "'j'", "'k'"]
kxi jkx ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b68310>)
dense(shape=(31, 31), size=961, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = B + 31*_k;
[_POINTER] float const* _B = A + 1*_k;
[_POINTER] float * _C = _tmp0 + 961*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 31*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 1*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 961*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'k'", "'i'", "'x'"] ["'x'", "'k'", "'j'"] ["'i'", "'j'", "'k'"]
kix xkj ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(31, 961), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>)
dense(shape=(31, 31), size=961, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 1*_k;
[_POINTER] float const* _B = B + 31*_k;
[_POINTER] float * _C = C + 961*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 31*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'i'", "'k'", "'x'"] ["'j'", "'x'", "'k'"] ["'i'", "'j'", "'k'"]
ikx jxk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b7b810>)
dense(shape=(31, 31), size=961, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 31*_k;
[_POINTER] float const* _B = B + 961*_k;
[_POINTER] float * _C = C + 961*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 31*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b7b810>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b7b810>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b7b810>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=True,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
[('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 31*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b7b810>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b7b810>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b7b810>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=True,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
0 ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
1 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 31*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
2 ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b7b810>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b7b810>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b7b810>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=True,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
Add:  DenseMatrix{name = A
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 961
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = B
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = C
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SINK
}
3 ('forLoopEnd', {})
{DenseMatrix{name = A, num. rows = 31, num. columns = 31, leading dimension = 961, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 31, 31]}, DenseMatrix{name = C, num. rows = 31, num. columns = 31, leading dimension = 31, direction = DataFlowDirection.SINK, bbox = [0, 0, 31, 31]}, DenseMatrix{name = B, num. rows = 31, num. columns = 31, leading dimension = 31, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 31, 31]}}
[('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 31*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b7b810>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b7b810>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b7b810>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=True,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 31*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b7b810>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b7b810>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b7b810>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=True,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
Calling external code generators...
{}
//Original Loop: const float* _A = A + 31*_k
//Original Loop: const float* _B = B + 961*_k
//Original Loop: float* _C = C + 961*_k
rows: 31, cols: 31, lid: 961, trans: False
Generating initialization code...
sloopOverGEMM_NT_NT_NT__d31_31_d31_31_d31_31__alpha_1_0_beta_0_0_p_p_p__9702a4f
const float * const * A, int A_extraOffset, const float * const * B, int B_extraOffset, float ** C, int C_extraOffset, unsigned numElements, unsigned* flags, void* streamPtr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
============================================
["'x'", "'i'", "'k'"] ["'x'", "'k'", "'j'"] ["'i'", "'j'", "'k'"]
xik xkj ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b5fdd0>)
dense(shape=(31, 31), size=961, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 961*_k;
[_POINTER] float const* _B = B + 31*_k;
[_POINTER] float * _C = C + 961*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 31*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b5fdd0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b5fdd0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b5fdd0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
[('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 31*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b5fdd0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b5fdd0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b5fdd0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
0 ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
1 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 31*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
2 ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b5fdd0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b5fdd0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b5fdd0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
Add:  DenseMatrix{name = A
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = B
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 961
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = C
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SINK
}
3 ('forLoopEnd', {})
{DenseMatrix{name = A, num. rows = 31, num. columns = 31, leading dimension = 31, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 31, 31]}, DenseMatrix{name = B, num. rows = 31, num. columns = 31, leading dimension = 961, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 31, 31]}, DenseMatrix{name = C, num. rows = 31, num. columns = 31, leading dimension = 31, direction = DataFlowDirection.SINK, bbox = [0, 0, 31, 31]}}
[('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 31*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b5fdd0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b5fdd0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b5fdd0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 31*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b5fdd0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b5fdd0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b5fdd0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
Calling external code generators...
{}
//Original Loop: const float* _A = A + 961*_k
//Original Loop: const float* _B = B + 31*_k
//Original Loop: float* _C = C + 961*_k
rows: 31, cols: 31, lid: 961, trans: False
Generating initialization code...
sloopOverGEMM_NT_NT_NT__d31_31_d31_31_d31_31__alpha_1_0_beta_0_0_p_p_p__d6f578f
const float * const * A, int A_extraOffset, const float * const * B, int B_extraOffset, float ** C, int C_extraOffset, unsigned numElements, unsigned* flags, void* streamPtr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
============================================
["'x'", "'k'", "'i'"] ["'x'", "'j'", "'k'"] ["'i'", "'j'", "'k'"]
xki xjk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b78e10>)
dense(shape=(31, 31), size=961, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 31*_k;
[_POINTER] float const* _B = B + 961*_k;
[_POINTER] float * _C = C + 961*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 31*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78e10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b78e10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78e10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
[('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 31*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78e10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b78e10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78e10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
0 ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
1 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 31*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
2 ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78e10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b78e10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78e10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
Add:  DenseMatrix{name = A
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 961
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = B
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = C
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SINK
}
3 ('forLoopEnd', {})
{DenseMatrix{name = A, num. rows = 31, num. columns = 31, leading dimension = 961, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 31, 31]}, DenseMatrix{name = C, num. rows = 31, num. columns = 31, leading dimension = 31, direction = DataFlowDirection.SINK, bbox = [0, 0, 31, 31]}, DenseMatrix{name = B, num. rows = 31, num. columns = 31, leading dimension = 31, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 31, 31]}}
[('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 31*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78e10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b78e10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78e10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 31*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78e10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b78e10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78e10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
Calling external code generators...
{}
//Original Loop: const float* _A = A + 31*_k
//Original Loop: const float* _B = B + 961*_k
//Original Loop: float* _C = C + 961*_k
Generating initialization code...
sloopOverGEMM_NT_NT_NT__d31_31_d31_31_d31_31__alpha_1_0_beta_0_0_p_p_p__9702a4f
const float * const * A, int A_extraOffset, const float * const * B, int B_extraOffset, float ** C, int C_extraOffset, unsigned numElements, unsigned* flags, void* streamPtr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
============================================
["'k'", "'x'", "'i'"] ["'x'", "'j'", "'k'"] ["'i'", "'j'", "'k'"]
kxi xjk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(31, 961), align=<yateto.arch.Architecture object at 0x7f5e86bb4410>)
dense(shape=(31, 31), size=961, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 1*_k;
[_POINTER] float const* _B = B + 961*_k;
[_POINTER] float * _C = C + 961*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'k'", "'i'", "'x'"] ["'x'", "'j'", "'k'"] ["'i'", "'j'", "'k'"]
kix xjk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(31, 961), align=<yateto.arch.Architecture object at 0x7f5e86bb5950>)
dense(shape=(31, 31), size=961, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 1*_k;
[_POINTER] float const* _B = B + 961*_k;
[_POINTER] float * _C = C + 961*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'k'", "'i'", "'x'"] ["'j'", "'x'", "'k'"] ["'i'", "'j'", "'k'"]
kix jxk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(31, 961), align=<yateto.arch.Architecture object at 0x7f5e86bb7a90>)
dense(shape=(31, 31), size=961, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 1*_k;
[_POINTER] float const* _B = B + 961*_k;
[_POINTER] float * _C = C + 961*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'i'", "'x'", "'k'"] ["'x'", "'k'", "'j'"] ["'i'", "'j'", "'k'"]
ixk xkj ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e86bb7890>)
dense(shape=(31, 31), size=961, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 961*_k;
[_POINTER] float const* _B = B + 31*_k;
[_POINTER] float * _C = C + 961*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 31*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e86bb7890>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e86bb7890>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e86bb7890>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
[('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 31*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e86bb7890>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e86bb7890>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e86bb7890>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
0 ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
1 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 31*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
2 ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e86bb7890>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e86bb7890>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e86bb7890>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
Add:  DenseMatrix{name = A
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = B
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 961
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = C
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SINK
}
3 ('forLoopEnd', {})
{DenseMatrix{name = A, num. rows = 31, num. columns = 31, leading dimension = 31, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 31, 31]}, DenseMatrix{name = C, num. rows = 31, num. columns = 31, leading dimension = 31, direction = DataFlowDirection.SINK, bbox = [0, 0, 31, 31]}, DenseMatrix{name = B, num. rows = 31, num. columns = 31, leading dimension = 961, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 31, 31]}}
[('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 31*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e86bb7890>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e86bb7890>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e86bb7890>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 31*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e86bb7890>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e86bb7890>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e86bb7890>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
Calling external code generators...
{}
//Original Loop: const float* _A = A + 961*_k
//Original Loop: const float* _B = B + 31*_k
//Original Loop: float* _C = C + 961*_k
rows: 31, cols: 31, lid: 961, trans: False
Generating initialization code...
sloopOverGEMM_NT_NT_NT__d31_31_d31_31_d31_31__alpha_1_0_beta_0_0_p_p_p__92ef405
const float * const * A, int A_extraOffset, const float * const * B, int B_extraOffset, float ** C, int C_extraOffset, unsigned numElements, unsigned* flags, void* streamPtr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
============================================
["'x'", "'i'", "'k'"] ["'j'", "'x'", "'k'"] ["'i'", "'j'", "'k'"]
xik jxk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b7b9d0>)
dense(shape=(31, 31), size=961, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = B + 961*_k;
[_POINTER] float const* _B = A + 961*_k;
[_POINTER] float * _C = _tmp0 + 961*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 961*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b7b9d0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b7b9d0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b7b9d0>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
Calling external code generators...
Generating initialization code...
Skip ScopScaleAdd
*********************************
============================================
["'i'", "'x'", "'k'"] ["'x'", "'j'", "'k'"] ["'i'", "'j'", "'k'"]
ixk xjk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>)
dense(shape=(31, 31), size=961, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 961*_k;
[_POINTER] float const* _B = B + 961*_k;
[_POINTER] float * _C = C + 961*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
[('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 961*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {}), ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
0 ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
1 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 961*_k'}})
2 ('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']})
Rename: DenseMatrix{name = tmp0
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = strided
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = None
}
Add:  DenseMatrix{name = B
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = A
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = tmp0
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = strided
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SINK
}
3 ('forLoopEnd', {})
4 ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
5 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
6 ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
Add:  DenseMatrix{name = A
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SOURCESINK
}
Add:  DenseMatrix{name = B
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SOURCESINK
}
Add:  DenseMatrix{name = C
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SINK
}
7 ('forLoopEnd', {})
{DenseMatrix{name = B, num. rows = 31, num. columns = 31, leading dimension = 31, direction = DataFlowDirection.SOURCESINK, bbox = [0, 0, 31, 31]}, DenseMatrix{name = tmp0, num. rows = 31, num. columns = 31, leading dimension = 31, direction = DataFlowDirection.SINK, bbox = [0, 0, 31, 31]}, DenseMatrix{name = C, num. rows = 31, num. columns = 31, leading dimension = 31, direction = DataFlowDirection.SINK, bbox = [0, 0, 31, 31]}, DenseMatrix{name = A, num. rows = 31, num. columns = 31, leading dimension = 31, direction = DataFlowDirection.SOURCESINK, bbox = [0, 0, 31, 31]}}
[('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 961*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {}), ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 961*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 961*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b78b10>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
Calling external code generators...
{'_tmp0': 961}
ADD: DenseMatrix{name = _tmp0_buffer
	num. rows = 961
	num. columns = 1
	bounding box = [0, 0, 961, 1]
	addressing = none
	num. actual rows = 961
	num. actual cols = 1
	leading dimension = 961
	direction = DataFlowDirection.SOURCESINK
}, AS SYMBOL: name: _tmp0_buffer, type: SymbolType.SharedMem
DenseMatrix{name = B
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SOURCESINK
} tmp0
DenseMatrix{name = tmp0
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = strided
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SINK
} tmp0
ADD: DenseMatrix{name = tmp0
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = strided
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SINK
}, AS SYMBOL: name: tmp0, type: SymbolType.SharedMem
DenseMatrix{name = C
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SINK
} tmp0
DenseMatrix{name = A
	num. rows = 31
	num. columns = 31
	bounding box = [0, 0, 31, 31]
	addressing = pointer_based
	num. actual rows = 31
	num. actual cols = 31
	leading dimension = 31
	direction = DataFlowDirection.SOURCESINK
} tmp0
//Original Loop: const float* _A = B + 961*_k
//Original Loop: const float* _B = A + 961*_k
//Original Loop: float* _C = _tmp0 + 961*_k
//Original Loop: const float* _A = A + 961*_k
//Original Loop: const float* _B = B + 961*_k
//Original Loop: float* _C = C + 961*_k
Generating initialization code...
sloopOverGEMM_NT_NT__d31_31_d31_31__alpha_1_0alpha_1_0_beta_0_0beta_0_0_s_p__4191929
float ** A, int A_extraOffset, float ** B, int B_extraOffset, float ** C, int C_extraOffset, unsigned numElements, unsigned* flags, void* streamPtr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
============================================
["'i'", "'x'", "'k'"] ["'k'", "'x'", "'j'"] ["'i'", "'j'", "'k'"]
ixk kxj ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e86bbe650>)
dense(shape=(31, 31), size=961, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 961*_k;
[_POINTER] float const* _B = B + 1*_k;
[_POINTER] float * _C = C + 961*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 961*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'x'", "'k'", "'i'"] ["'j'", "'x'", "'k'"] ["'i'", "'j'", "'k'"]
xki jxk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b79610>)
dense(shape=(31, 31), size=961, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '31', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = B + 961*_k;
[_POINTER] float const* _B = A + 31*_k;
[_POINTER] float * _C = _tmp0 + 961*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 961*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 31*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 961*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b79610>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 31), align=<yateto.arch.Architecture object at 0x7f5e94b79610>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(31, 31), bbox=BoundingBox(Range(0, 31), Range(0, 31)), stride=(1, 961), align=<yateto.arch.Architecture object at 0x7f5e94b79610>),	  eqspp=dense(shape=(31, 31), size=961, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=False,	  mnk=(Range(0, 31), Range(0, 31), Range(0, 31))), 'matrix_a': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_b': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 961, direction = None, bbox = [0, 0, 31, 31]}, 'matrix_c': DenseMatrix{name = None, num. rows = 31, num. columns = 31, leading dimension = 31, direction = None, bbox = [0, 0, 31, 31]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
Calling external code generators...
Generating initialization code...
Skip ScopScaleAdd
*********************************
============================================
["'x'", "'k'", "'i'"] ["'k'", "'x'", "'j'"] ["'i'", "'j'", "'k'"]
xki kxj ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e94b68ed0>)
dense(shape=(32, 32), size=1024, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 32*_k;
[_POINTER] float const* _B = B + 1*_k;
[_POINTER] float * _C = C + 1024*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 32*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'k'", "'x'", "'i'"] ["'j'", "'k'", "'x'"] ["'i'", "'j'", "'k'"]
kxi jkx ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bc8e90>)
dense(shape=(32, 32), size=1024, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = B + 32*_k;
[_POINTER] float const* _B = A + 1*_k;
[_POINTER] float * _C = _tmp0 + 1024*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 32*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 1*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 1024*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'k'", "'i'", "'x'"] ["'x'", "'k'", "'j'"] ["'i'", "'j'", "'k'"]
kix xkj ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(32, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bbc410>)
dense(shape=(32, 32), size=1024, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 1*_k;
[_POINTER] float const* _B = B + 32*_k;
[_POINTER] float * _C = C + 1024*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 32*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'i'", "'k'", "'x'"] ["'j'", "'x'", "'k'"] ["'i'", "'j'", "'k'"]
ikx jxk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>)
dense(shape=(32, 32), size=1024, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 32*_k;
[_POINTER] float const* _B = B + 1024*_k;
[_POINTER] float * _C = C + 1024*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 32*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=True,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
[('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 32*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=True,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
0 ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
1 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 32*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
2 ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=True,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
Add:  DenseMatrix{name = A
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 1024
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = B
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = C
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SINK
}
3 ('forLoopEnd', {})
{DenseMatrix{name = C, num. rows = 32, num. columns = 32, leading dimension = 32, direction = DataFlowDirection.SINK, bbox = [0, 0, 32, 32]}, DenseMatrix{name = B, num. rows = 32, num. columns = 32, leading dimension = 32, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 32, 32]}, DenseMatrix{name = A, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 32, 32]}}
[('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 32*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=True,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 32*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b6a0d0>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=True,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
Calling external code generators...
{}
//Original Loop: const float* _A = A + 32*_k
//Original Loop: const float* _B = B + 1024*_k
//Original Loop: float* _C = C + 1024*_k
rows: 32, cols: 32, lid: 1024, trans: False
Generating initialization code...
sloopOverGEMM_NT_NT_NT__d32_32_d32_32_d32_32__alpha_1_0_beta_0_0_p_p_p__141e162
const float * const * A, int A_extraOffset, const float * const * B, int B_extraOffset, float ** C, int C_extraOffset, unsigned numElements, unsigned* flags, void* streamPtr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
============================================
["'x'", "'i'", "'k'"] ["'x'", "'k'", "'j'"] ["'i'", "'j'", "'k'"]
xik xkj ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bcae90>)
dense(shape=(32, 32), size=1024, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 1024*_k;
[_POINTER] float const* _B = B + 32*_k;
[_POINTER] float * _C = C + 1024*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 32*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bcae90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bcae90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bcae90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
[('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 32*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bcae90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bcae90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bcae90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
0 ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
1 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 32*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
2 ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bcae90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bcae90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bcae90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
Add:  DenseMatrix{name = A
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = B
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 1024
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = C
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SINK
}
3 ('forLoopEnd', {})
{DenseMatrix{name = B, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 32, 32]}, DenseMatrix{name = C, num. rows = 32, num. columns = 32, leading dimension = 32, direction = DataFlowDirection.SINK, bbox = [0, 0, 32, 32]}, DenseMatrix{name = A, num. rows = 32, num. columns = 32, leading dimension = 32, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 32, 32]}}
[('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 32*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bcae90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bcae90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bcae90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 32*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bcae90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bcae90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bcae90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
Calling external code generators...
{}
//Original Loop: const float* _A = A + 1024*_k
//Original Loop: const float* _B = B + 32*_k
//Original Loop: float* _C = C + 1024*_k
rows: 32, cols: 32, lid: 1024, trans: False
Generating initialization code...
sloopOverGEMM_NT_NT_NT__d32_32_d32_32_d32_32__alpha_1_0_beta_0_0_p_p_p__6af4a32
const float * const * A, int A_extraOffset, const float * const * B, int B_extraOffset, float ** C, int C_extraOffset, unsigned numElements, unsigned* flags, void* streamPtr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
============================================
["'x'", "'k'", "'i'"] ["'x'", "'j'", "'k'"] ["'i'", "'j'", "'k'"]
xki xjk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bdcb90>)
dense(shape=(32, 32), size=1024, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 32*_k;
[_POINTER] float const* _B = B + 1024*_k;
[_POINTER] float * _C = C + 1024*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 32*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bdcb90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bdcb90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bdcb90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
[('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 32*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bdcb90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bdcb90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bdcb90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
0 ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
1 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 32*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
2 ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bdcb90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bdcb90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bdcb90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
Add:  DenseMatrix{name = A
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 1024
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = B
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = C
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SINK
}
3 ('forLoopEnd', {})
{DenseMatrix{name = A, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 32, 32]}, DenseMatrix{name = C, num. rows = 32, num. columns = 32, leading dimension = 32, direction = DataFlowDirection.SINK, bbox = [0, 0, 32, 32]}, DenseMatrix{name = B, num. rows = 32, num. columns = 32, leading dimension = 32, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 32, 32]}}
[('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 32*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bdcb90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bdcb90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bdcb90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 32*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bdcb90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bdcb90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bdcb90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=True,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=False,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
Calling external code generators...
{}
//Original Loop: const float* _A = A + 32*_k
//Original Loop: const float* _B = B + 1024*_k
//Original Loop: float* _C = C + 1024*_k
Generating initialization code...
sloopOverGEMM_NT_NT_NT__d32_32_d32_32_d32_32__alpha_1_0_beta_0_0_p_p_p__092c876
const float * const * A, int A_extraOffset, const float * const * B, int B_extraOffset, float ** C, int C_extraOffset, unsigned numElements, unsigned* flags, void* streamPtr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
============================================
["'k'", "'x'", "'i'"] ["'x'", "'j'", "'k'"] ["'i'", "'j'", "'k'"]
kxi xjk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(32, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bcbf10>)
dense(shape=(32, 32), size=1024, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 1*_k;
[_POINTER] float const* _B = B + 1024*_k;
[_POINTER] float * _C = C + 1024*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'k'", "'i'", "'x'"] ["'x'", "'j'", "'k'"] ["'i'", "'j'", "'k'"]
kix xjk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(32, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bc8090>)
dense(shape=(32, 32), size=1024, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 1*_k;
[_POINTER] float const* _B = B + 1024*_k;
[_POINTER] float * _C = C + 1024*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'k'", "'i'", "'x'"] ["'j'", "'x'", "'k'"] ["'i'", "'j'", "'k'"]
kix jxk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(32, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bca350>)
dense(shape=(32, 32), size=1024, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 1*_k;
[_POINTER] float const* _B = B + 1024*_k;
[_POINTER] float * _C = C + 1024*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'i'", "'x'", "'k'"] ["'x'", "'k'", "'j'"] ["'i'", "'j'", "'k'"]
ixk xkj ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b78150>)
dense(shape=(32, 32), size=1024, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 1024*_k;
[_POINTER] float const* _B = B + 32*_k;
[_POINTER] float * _C = C + 1024*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 32*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b78150>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b78150>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e94b78150>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
[('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 32*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b78150>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b78150>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e94b78150>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
0 ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
1 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 32*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
2 ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b78150>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b78150>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e94b78150>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
Add:  DenseMatrix{name = A
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = B
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 1024
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = C
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SINK
}
3 ('forLoopEnd', {})
{DenseMatrix{name = C, num. rows = 32, num. columns = 32, leading dimension = 32, direction = DataFlowDirection.SINK, bbox = [0, 0, 32, 32]}, DenseMatrix{name = B, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 32, 32]}, DenseMatrix{name = A, num. rows = 32, num. columns = 32, leading dimension = 32, direction = DataFlowDirection.SOURCE, bbox = [0, 0, 32, 32]}}
[('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 32*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b78150>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b78150>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e94b78150>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 32*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b78150>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e94b78150>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e94b78150>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
Calling external code generators...
{}
//Original Loop: const float* _A = A + 1024*_k
//Original Loop: const float* _B = B + 32*_k
//Original Loop: float* _C = C + 1024*_k
rows: 32, cols: 32, lid: 1024, trans: False
Generating initialization code...
sloopOverGEMM_NT_NT_NT__d32_32_d32_32_d32_32__alpha_1_0_beta_0_0_p_p_p__c64f0b3
const float * const * A, int A_extraOffset, const float * const * B, int B_extraOffset, float ** C, int C_extraOffset, unsigned numElements, unsigned* flags, void* streamPtr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
============================================
["'x'", "'i'", "'k'"] ["'j'", "'x'", "'k'"] ["'i'", "'j'", "'k'"]
xik jxk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bcfd90>)
dense(shape=(32, 32), size=1024, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = B + 1024*_k;
[_POINTER] float const* _B = A + 1024*_k;
[_POINTER] float * _C = _tmp0 + 1024*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 1024*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bcfd90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bcfd90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bcfd90>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
Calling external code generators...
Generating initialization code...
Skip ScopScaleAdd
*********************************
============================================
["'i'", "'x'", "'k'"] ["'x'", "'j'", "'k'"] ["'i'", "'j'", "'k'"]
ixk xjk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>)
dense(shape=(32, 32), size=1024, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 1024*_k;
[_POINTER] float const* _B = B + 1024*_k;
[_POINTER] float * _C = C + 1024*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
[('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 1024*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {}), ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
0 ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
1 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 1024*_k'}})
2 ('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']})
Rename: DenseMatrix{name = tmp0
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = strided
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = None
}
Add:  DenseMatrix{name = B
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = A
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SOURCE
}
Add:  DenseMatrix{name = tmp0
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = strided
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SINK
}
3 ('forLoopEnd', {})
4 ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
5 ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
6 ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
Add:  DenseMatrix{name = A
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SOURCESINK
}
Add:  DenseMatrix{name = B
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SOURCESINK
}
Add:  DenseMatrix{name = C
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SINK
}
7 ('forLoopEnd', {})
{DenseMatrix{name = C, num. rows = 32, num. columns = 32, leading dimension = 32, direction = DataFlowDirection.SINK, bbox = [0, 0, 32, 32]}, DenseMatrix{name = tmp0, num. rows = 32, num. columns = 32, leading dimension = 32, direction = DataFlowDirection.SINK, bbox = [0, 0, 32, 32]}, DenseMatrix{name = A, num. rows = 32, num. columns = 32, leading dimension = 32, direction = DataFlowDirection.SOURCESINK, bbox = [0, 0, 32, 32]}, DenseMatrix{name = B, num. rows = 32, num. columns = 32, leading dimension = 32, direction = DataFlowDirection.SOURCESINK, bbox = [0, 0, 32, 32]}}
[('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 1024*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {}), ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'}), ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}}), ('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']}), ('forLoopEnd', {})]
('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 1024*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
('gemm', {'descr': Description(  result=TensorDescription(  name=C,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  leftTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bce990>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['A, extraOffset_A', 'B, extraOffset_B', 'C, extraOffset_C', 'numElements', 'flags', 'streamPtr']})
('forLoopEnd', {})
Calling external code generators...
{'_tmp0': 1024}
ADD: DenseMatrix{name = _tmp0_buffer
	num. rows = 1024
	num. columns = 1
	bounding box = [0, 0, 1024, 1]
	addressing = none
	num. actual rows = 1024
	num. actual cols = 1
	leading dimension = 1024
	direction = DataFlowDirection.SOURCESINK
}, AS SYMBOL: name: _tmp0_buffer, type: SymbolType.SharedMem
DenseMatrix{name = C
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SINK
} tmp0
DenseMatrix{name = tmp0
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = strided
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SINK
} tmp0
ADD: DenseMatrix{name = tmp0
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = strided
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SINK
}, AS SYMBOL: name: tmp0, type: SymbolType.SharedMem
DenseMatrix{name = A
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SOURCESINK
} tmp0
DenseMatrix{name = B
	num. rows = 32
	num. columns = 32
	bounding box = [0, 0, 32, 32]
	addressing = pointer_based
	num. actual rows = 32
	num. actual cols = 32
	leading dimension = 32
	direction = DataFlowDirection.SOURCESINK
} tmp0
//Original Loop: const float* _A = B + 1024*_k
//Original Loop: const float* _B = A + 1024*_k
//Original Loop: float* _C = _tmp0 + 1024*_k
//Original Loop: const float* _A = A + 1024*_k
//Original Loop: const float* _B = B + 1024*_k
//Original Loop: float* _C = C + 1024*_k
Generating initialization code...
sloopOverGEMM_NT_NT__d32_32_d32_32__alpha_1_0alpha_1_0_beta_0_0beta_0_0_p_s__88ab7da
float ** A, int A_extraOffset, float ** B, int B_extraOffset, float ** C, int C_extraOffset, unsigned numElements, unsigned* flags, void* streamPtr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
============================================
["'i'", "'x'", "'k'"] ["'k'", "'x'", "'j'"] ["'i'", "'j'", "'k'"]
ixk kxj ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bbc8d0>)
dense(shape=(32, 32), size=1024, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = A + 1024*_k;
[_POINTER] float const* _B = B + 1*_k;
[_POINTER] float * _C = C + 1024*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'A', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'B', 'offset': ' + 1*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': 'C', 'offset': ' + 1024*_k'}})
Non-unit stride GEMM required in both dimensions, it is not supported by Gemmforge yet
*********************************
============================================
["'x'", "'k'", "'i'"] ["'j'", "'x'", "'k'"] ["'i'", "'j'", "'k'"]
xki jxk ijk
Deducing indices...
Generating unit tests...
Optimizing ASTs...
kernel
Generating kernels...
DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bbec10>)
dense(shape=(32, 32), size=1024, ndim=2)
APPEND:  ('forLoopBegin', {'start': '0', 'stop': '32', 'index': '_k', 'iter': '++'})
INNERLOOPBODY
INNTERLOOPBODY HASOUTERLOOPS
k
[_POINTER] float const* _A = B + 1024*_k;
[_POINTER] float const* _B = A + 32*_k;
[_POINTER] float * _C = _tmp0 + 1024*_k;
APPEND:  ('InnerLoopBody', {'lhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_A', 'rhs': 'B', 'offset': ' + 1024*_k'}, 'rhs': {'float_type': 'float', 'const_identifier': 'const', 'lhs': '_B', 'rhs': 'A', 'offset': ' + 32*_k'}, 'result': {'float_type': 'float', 'const_identifier': '', 'lhs': '_C', 'rhs': '_tmp0', 'offset': ' + 1024*_k'}})
APPEND:  ('gemm', {'descr': Description(  result=TensorDescription(  name=_tmp0,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bbec10>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=True),	  leftTerm=TensorDescription(  name=B,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 32), align=<yateto.arch.Architecture object at 0x7f5e86bbec10>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  rightTerm=TensorDescription(  name=A,	  memoryLayout=DenseMemoryLayout(shape=(32, 32), bbox=BoundingBox(Range(0, 32), Range(0, 32)), stride=(1, 1024), align=<yateto.arch.Architecture object at 0x7f5e86bbec10>),	  eqspp=dense(shape=(32, 32), size=1024, ndim=2),	  is_compute_constant=False,	  is_temporary=False),	  transA=False,	  transB=False,	  alpha=1.0,	  beta=0.0,	  prefetchName=None,	  isACsc=False,	  isBCsc=False,	  alignedA=True,	  alignedC=True,	  mnk=(Range(0, 32), Range(0, 32), Range(0, 32))), 'matrix_a': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_b': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 1024, direction = None, bbox = [0, 0, 32, 32]}, 'matrix_c': DenseMatrix{name = None, num. rows = 32, num. columns = 32, leading dimension = 32, direction = None, bbox = [0, 0, 32, 32]}, 'args': ['B, extraOffset_B', 'A, extraOffset_A', '_tmp0, 0', 'numElements', 'flags', 'streamPtr']})
APPEND:  ('forLoopEnd', {})
Calling external code generators...
Generating initialization code...
Skip ScopScaleAdd
*********************************
